package config

import (
	"fmt"

	"gopkg.in/yaml.v2"
)

type Mapping struct {
	Tables            Tables            `yaml:"tables"`
	GeneralizedTables GeneralizedTables `yaml:"generalized_tables"`
	Tags              Tags              `yaml:"tags"`
	Areas             Areas             `yaml:"areas"`
	// SingleIDSpace mangles the overlapping node/way/relation IDs
	// to be unique (nodes positive, ways negative, relations negative -1e17)
	SingleIDSpace bool `yaml:"use_single_id_space"`
}

type Column struct {
	Name       string                       `yaml:"name"`
	Key        Key                          `yaml:"key"`
	Keys       []Key                        `yaml:"keys"`
	Type       string                       `yaml:"type"`
	Args       map[string]interface{}       `yaml:"args"`
	Aliases    map[string]map[string]string `yaml:"aliases"`
	// GeometryTransform can be used to transform geometry columns before insertion.
	GeometryTransform string `yaml:"geometry_transform"`
	FromMember bool                         `yaml:"from_member"`
	Comment    string                       `yaml:"#"`
}

type Tables map[string]*Table
type Table struct {
	Name              string
	Type              string                `yaml:"type"`
	Mapping           KeyValues             `yaml:"mapping"`
	Mappings          map[string]SubMapping `yaml:"mappings"`
	TypeMappings      TypeMappings          `yaml:"type_mappings"`
	Columns           []*Column             `yaml:"columns"`
	OldFields         []*Column             `yaml:"fields"`
	Filters           *Filters              `yaml:"filters"`
	RelationTypes     []string              `yaml:"relation_types"`
	Comment           string                `yaml:"_comment"`
	MultiValues       []Key                 `yaml:"multi_values"`
}

type GeneralizedTables map[string]*GeneralizedTable
type GeneralizedTable struct {
	Name            string
	SourceTableName string  `yaml:"source"`
	Tolerance       float64 `yaml:"tolerance"`
	SQLFilter       string  `yaml:"sql_filter"`
}

type Filters struct {
	ExcludeTags   *[][]string    `yaml:"exclude_tags"`
	Reject        KeyValues      `yaml:"reject"`
	Require       KeyValues      `yaml:"require"`
	RejectRegexp  KeyRegexpValue `yaml:"reject_regexp"`
	RequireRegexp KeyRegexpValue `yaml:"require_regexp"`
}

type Areas struct {
	AreaTags   []Key `yaml:"area_tags"`
	LinearTags []Key `yaml:"linear_tags"`
}

type Tags struct {
	LoadAll bool  `yaml:"load_all"`
	Exclude []Key `yaml:"exclude"`
	Include []Key `yaml:"include"`
}

type Key string
type Value string

type OrderedValue struct {
	Value
	Order int
}

type KeyValues map[Key][]OrderedValue
type KeyRegexpValue map[Key]string

func (kv *KeyValues) UnmarshalYAML(unmarshal func(interface{}) error) error {
	if *kv == nil {
		*kv = make(map[Key][]OrderedValue)
	}
	slice := yaml.MapSlice{}
	err := unmarshal(&slice)
	if err != nil {
		return err
	}
	order := 0
	for _, item := range slice {
		k, ok := item.Key.(string)
		if !ok {
			return fmt.Errorf("mapping key '%s' not a string", k)
		}
		values, ok := item.Value.([]interface{})
		if !ok {
			return fmt.Errorf("mapping key '%s' not a string", k)
		}
		for _, v := range values {
			if s, ok := v.(string); ok {
				(*kv)[Key(k)] = append((*kv)[Key(k)], OrderedValue{Value: Value(s), Order: order})
			} else {
				return fmt.Errorf("mapping value '%v' for mapping key '%s' not a string", v, k)
			}
			order++
		}
	}
	return nil
}

type SubMapping struct {
	Mapping KeyValues
}

type TypeMappings struct {
	Points      TypeMapping `yaml:"points"`
	LineStrings TypeMapping `yaml:"linestrings"`
	Polygons    TypeMapping `yaml:"polygons"`
	Any         TypeMapping `yaml:"any"`
}

type TypeMapping struct {
	Mapping  KeyValues             `yaml:"mapping"`
	Mappings map[string]SubMapping `yaml:"mappings"`
}

func (tm *TypeMapping) UnmarshalYAML(unmarshal func(interface{}) error) error {
	raw := map[interface{}]interface{}{}
	if err := unmarshal(&raw); err != nil {
		return err
	}
	_, hasMapping := raw["mapping"]
	_, hasMappings := raw["mappings"]
	if hasMapping || hasMappings {
		type alias TypeMapping
		var parsed alias
		if err := unmarshal(&parsed); err != nil {
			return err
		}
		*tm = TypeMapping(parsed)
		return nil
	}

	var kv KeyValues
	if err := unmarshal(&kv); err != nil {
		return err
	}
	tm.Mapping = kv
	return nil
}
